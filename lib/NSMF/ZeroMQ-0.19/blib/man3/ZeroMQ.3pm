.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ZeroMQ 3pm"
.TH ZeroMQ 3pm "2011-12-08" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ZeroMQ \- A ZeroMQ2 wrapper for Perl
.SH "SYNOPSIS ( HIGH-LEVEL API )"
.IX Header "SYNOPSIS ( HIGH-LEVEL API )"
.Vb 2
\&    # echo server
\&    use ZeroMQ qw/:all/;
\&
\&    my $cxt = ZeroMQ::Context\->new;
\&    my $sock = $cxt\->socket(ZMQ_REP);
\&    $sock\->bind($addr);
\&  
\&    my $msg;
\&    foreach (1..$roundtrip_count) {
\&        $msg = $sock\->recv();
\&        $sock\->send($msg);
\&    }
\&
\&    # json (if JSON.pm is available)
\&    $sock\->send_as( json => { foo => "bar" } );
\&    my $thing = $sock\->recv_as( "json" );
\&
\&    # custom serialization
\&    ZeroMQ::register_read_type(myformat => sub { ... });
\&    ZeroMQ::register_write_type(myformat => sub { .. });
\&
\&    $sock\->send_as( myformat => $data ); # serialize using above callback
\&    my $thing = $sock\->recv_as( "myformat" );
.Ve
.SH "SYNOPSIS ( LOW-LEVEL API )"
.IX Header "SYNOPSIS ( LOW-LEVEL API )"
.Vb 1
\&    use ZeroMQ::Raw;
\&
\&    my $ctxt = zmq_init($threads);
\&    my $rv   = zmq_term($ctxt);
\&
\&    my $msg  = zmq_msg_init();
\&    my $msg  = zmq_msg_init_size( $size );
\&    my $msg  = zmq_msg_init_data( $data );
\&    my $rv   = zmq_msg_close( $msg );
\&    my $rv   = zmq_msg_move( $dest, $src );
\&    my $rv   = zmq_msg_copy( $dest, $src );
\&    my $data = zmq_msg_data( $msg );
\&    my $size = zmq_msg_size( $msg);
\&
\&    my $sock = zmq_socket( $ctxt, $type );
\&    my $rv   = zmq_close( $sock );
\&    my $rv   = zmq_setsockopt( $socket, $option, $value );
\&    my $val  = zmq_getsockopt( $socket, $option );
\&    my $rv   = zmq_bind( $sock, $addr );
\&    my $rv   = zmq_send( $sock, $msg, $flags );
\&    my $msg  = zmq_recv( $sock, $flags );
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
If you have libzmq registered with pkg-config:
.PP
.Vb 4
\&    perl Makefile.PL
\&    make 
\&    make test
\&    make install
.Ve
.PP
If you don't have pkg-config, and libzmq is installed under /usr/local/libzmq:
.PP
.Vb 5
\&    ZMQ_HOME=/usr/local/libzmq \e
\&        perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.PP
If you want to customize include directories and such:
.PP
.Vb 7
\&    ZMQ_INCLUDES=/path/to/libzmq/include \e
\&    ZMQ_LIBS=/path/to/libzmq/lib \e
\&    ZMQ_H=/path/to/libzmq/include/zmq.h \e
\&        perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.PP
If you want to compile with debugging on:
.PP
.Vb 1
\&    perl Makefile.PL \-g
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`ZeroMQ\*(C'\fR module is a wrapper of the 0MQ message passing library for Perl. 
It's a thin wrapper around the C \s-1API\s0. Please read <http://zeromq.org> for
more details on ZeroMQ.
.SH "CLASS WALKTHROUGH"
.IX Header "CLASS WALKTHROUGH"
.IP "ZeroMQ::Raw" 4
.IX Item "ZeroMQ::Raw"
Use ZeroMQ::Raw to get access to the C \s-1API\s0 such as \f(CW\*(C`zmq_init\*(C'\fR, \f(CW\*(C`zmq_socket\*(C'\fR, et al. Functions provided in this low level \s-1API\s0 should follow the C \s-1API\s0 exactly.
.IP "ZeroMQ::Constants" 4
.IX Item "ZeroMQ::Constants"
ZeroMQ::Constants contains all of the constants that are known to be extractable from zmq.h. Do note that sometimes the list changes due to additions/deprecations in the underlying zeromq2 library. We try to do our best to make things available (at least to warn you that some symbols are deprecated), but it may not always be possible.
.IP "ZeroMQ::Context" 4
.IX Item "ZeroMQ::Context"
.PD 0
.IP "ZeroMQ::Socket" 4
.IX Item "ZeroMQ::Socket"
.IP "ZeroMQ::Message" 4
.IX Item "ZeroMQ::Message"
.PD
ZeroMQ::Context, ZeroMQ::Socket, ZeroMQ::Message contain the high-level, more perl-ish interface to the zeromq functionalities.
.IP "ZeroMQ" 4
.IX Item "ZeroMQ"
Loading \f(CW\*(C`ZeroMQ\*(C'\fR will make the ZeroMQ::Context, ZeroMQ::Socket, and 
ZeroMQ::Message classes available as well.
.SH "BASIC USAGE"
.IX Header "BASIC USAGE"
To start using ZeroMQ, you need to create a context object, then as many ZeroMQ::Socket as you need:
.PP
.Vb 2
\&    my $ctxt = ZeroMQ::Context\->new;
\&    my $socket = $ctxt\->socket( ... options );
.Ve
.PP
You need to call \f(CW\*(C`bind()\*(C'\fR or \f(CW\*(C`connect()\*(C'\fR on the socket, depending on your usage. For example on a typical server-client model you would write on the server side:
.PP
.Vb 1
\&    $socket\->bind( "tcp://127.0.0.1:9999" );
.Ve
.PP
and on the client side:
.PP
.Vb 1
\&    $socket\->connect( "tcp://127.0.0.1:9999" );
.Ve
.PP
The underlying zeromq library offers \s-1TCP\s0, multicast, in-process, and ipc connection patterns. Read the zeromq manual for more details on other ways to setup the socket.
.PP
When sending data, you can either pass a ZeroMQ::Message object or a Perl string.
.PP
.Vb 4
\&    # the following two send() calls are equivalent
\&    my $msg = ZeroMQ::Message\->new( "a simple message" );
\&    $socket\->send( $msg );
\&    $socket\->send( "a simple message" );
.Ve
.PP
In most cases using ZeroMQ::Message is redundunt, so you will most likely use the string version.
.PP
To receive, simply call \f(CW\*(C`recv()\*(C'\fR on the socket
.PP
.Vb 1
\&    my $msg = $socket\->recv;
.Ve
.PP
The received message is an instance of ZeroMQ::Message object, and you can access the content held in the message via the \f(CW\*(C`data()\*(C'\fR method:
.PP
.Vb 1
\&    my $data = $msg\->data;
.Ve
.SH "SERIALIZATION"
.IX Header "SERIALIZATION"
ZeroMQ.pm comes with a simple serialization/deserialization mechanism.
.PP
To serialize, use \f(CW\*(C`register_write_type()\*(C'\fR to register a name and an
associated callback to serialize the data. For example, for \s-1JSON\s0 we do
the following (this is already done for you in ZeroMQ.pm if you have
\&\s-1JSON\s0.pm installed):
.PP
.Vb 3
\&    use JSON ();
\&    ZeroMQ::register_write_type(\*(Aqjson\*(Aq => \e&JSON::encode_json);
\&    ZeroMQ::register_read_type(\*(Aqjson\*(Aq => \e&JSON::decode_json);
.Ve
.PP
Then you can use \f(CW\*(C`send_as()\*(C'\fR and \f(CW\*(C`recv_as()\*(C'\fR to specify the serialization 
type as the first argument:
.PP
.Vb 2
\&    my $ctxt = ZeroMQ::Context\->new();
\&    my $sock = $ctxt\->socket( ZMQ_REQ );
\&
\&    $sock\->send_as( json => $complex_perl_data_structure );
.Ve
.PP
The otherside will receive a \s-1JSON\s0 encoded data. The receivind side
can be written as:
.PP
.Vb 2
\&    my $ctxt = ZeroMQ::Context\->new();
\&    my $sock = $ctxt\->socket( ZMQ_REP );
\&
\&    my $complex_perl_data_structure = $sock\->recv_as( \*(Aqjson\*(Aq );
.Ve
.PP
If you have \s-1JSON\s0.pm (must be 2.00 or above), then the \s-1JSON\s0 serializer / 
deserializer is automatically enabled. If you want to tweak the serializer
option, do something like this:
.PP
.Vb 3
\&    my $coder = JSON\->new\->utf8\->pretty; # pretty print
\&    ZeroMQ::register_write_type( json => sub { $coder\->encode($_[0]) } );
\&    ZeroMQ::register_read_type( json => sub { $coder\->decode($_[0]) } );
.Ve
.PP
Note that this will have a \s-1GLOBAL\s0 effect. If you want to change only
your application, use a name that's different from 'json'.
.SH "ASYNCHRONOUS I/O WITH ZEROMQ"
.IX Header "ASYNCHRONOUS I/O WITH ZEROMQ"
By default ZeroMQ comes with its own \fIzmq_poll()\fR mechanism that can handle
non-blocking sockets. You can use this by calling zmq_poll with a list of
hashrefs:
.PP
.Vb 12
\&    zmq_poll([
\&        {
\&            fd => fileno(STDOUT),
\&            events => ZMQ_POLLOUT,
\&            callback => \e&callback,
\&        },
\&        {
\&            socket => $zmq_socket,
\&            events => ZMQ_POLLIN,
\&            callback => \e&callback
\&        },
\&    ], $timeout );
.Ve
.PP
Unfortunately this custom polling scheme doesn't play too well with AnyEvent.
.PP
As of zeromq2\-2.1.0, you can use getsockopt to retrieve the underlying file
descriptor, so use that to integrate ZeroMQ and AnyEvent:
.PP
.Vb 8
\&    my $socket = zmq_socket( $ctxt, ZMQ_REP );
\&    my $fh = zmq_getsockopt( $socket, ZMQ_FD );
\&    my $w; $w = AE::io $fh, 0, sub {
\&        while ( my $msg = zmq_recv( $socket, ZMQ_RCVMORE ) ) {
\&            # do something with $msg;
\&        }
\&        undef $w;
\&    };
.Ve
.SH "NOTES ON MULTI-PROCESS and MULTI-THREADED USAGE"
.IX Header "NOTES ON MULTI-PROCESS and MULTI-THREADED USAGE"
ZeroMQ works on both multi-process and multi-threaded use cases, but you need
to be careful bout sharing ZeroMQ objects.
.PP
For multi-process environments, you should not be sharing the context object.
Create separate contexts for each process, and therefore you shouldn't
be sharing the socket objects either.
.PP
For multi-thread environemnts, you can share the same context object. However
you cannot share sockets.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\fIversion()\fP"
.IX Subsection "version()"
Returns the version of the underlying zeromq library that is being linked.
In scalar context, returns a dotted version string. In list context,
returns a 3\-element list of the version numbers:
.PP
.Vb 2
\&    my $version_string = ZeroMQ::version();
\&    my ($major, $minor, $patch) = ZeroMQ::version();
.Ve
.ie n .SS "device($type, $sock1, $sock2)"
.el .SS "device($type, \f(CW$sock1\fP, \f(CW$sock2\fP)"
.IX Subsection "device($type, $sock1, $sock2)"
.SS "register_read_type($name, \e&callback)"
.IX Subsection "register_read_type($name, &callback)"
Register a read callback for a given \f(CW$name\fR. This is used in \f(CW\*(C`recv_as()\*(C'\fR.
The callback receives the data received from the socket.
.SS "register_write_type($name, \e&callback)"
.IX Subsection "register_write_type($name, &callback)"
Register a write callback for a given \f(CW$name\fR. This is used in \f(CW\*(C`send_as()\*(C'\fR
The callback receives the Perl structure given to \f(CW\*(C`send_as()\*(C'\fR
.SH "CAVEATS"
.IX Header "CAVEATS"
This is an early release. Proceed with caution, please report
(or better yet: fix) bugs you encounter.
.PP
This module has been tested againt \fBzeromq 2.1.4\fR. Semantics of this
module rely heavily on the underlying zeromq version. Make sure
you know which version of zeromq you're working with.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
ZeroMQ::Raw, ZeroMQ::Context, ZeroMQ::Socket, ZeroMQ::Message
.PP
<http://zeromq.org>
.PP
<http://github.com/lestrrat/ZeroMQ\-Perl>
.SH "AUTHOR"
.IX Header "AUTHOR"
Daisuke Maki \f(CW\*(C`<daisuke@endeworks.jp>\*(C'\fR
.PP
Steffen Mueller, \f(CW\*(C`<smueller@cpan.org>\*(C'\fR
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
The ZeroMQ module is
.PP
Copyright (C) 2010 by Daisuke Maki
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.0 or,
at your option, any later version of Perl 5 you may have available.
